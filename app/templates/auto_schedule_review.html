{% extends "base.html" %}

{% block title %}Review Auto-Schedule Proposal - Product Connections{% endblock %}

{% block extra_head %}
<link rel="stylesheet" href="{{ url_for('static', filename='css/pages/auto-schedule-review.css') }}">
{% endblock %}

{% block content %}
<div class="review-container">
    <div id="message-container"></div>

    {% if run %}
    <div class="review-header">
        <h1>Review Auto-Schedule Proposal</h1>
        <p>Review the proposed schedule changes below. You can edit individual assignments before approving.</p>

        <div class="review-stats" id="stats-container">
            <div class="stat-card success">
                <h3>Newly Scheduled</h3>
                <div class="value" id="stat-scheduled">-</div>
                <div class="stat-description">Placed in empty slots</div>
            </div>
            <div class="stat-card warning">
                <h3>Bumped Events</h3>
                <div class="value" id="stat-swaps">-</div>
                <div class="stat-description">Replaced less urgent events</div>
            </div>
            <div class="stat-card error">
                <h3>Failed</h3>
                <div class="value" id="stat-failed">-</div>
                <div class="stat-description">Could not be scheduled</div>
            </div>
            <div class="stat-card">
                <h3>Total Processed</h3>
                <div class="value" id="stat-total">-</div>
                <div class="stat-description">Events in scheduling window</div>
            </div>
        </div>
    </div>

    <!-- Schedule Verification Section -->
    <div class="section" id="verification-section" style="display: none;">
        <h2>
            <span id="verification-icon">üîç</span> Schedule Verification
            <span class="count-badge" id="verification-badge">Checking...</span>
        </h2>
        <div id="verification-content">
            <div class="loading">
                <div class="loading-spinner"></div>
                <p>Running schedule verification...</p>
            </div>
        </div>
    </div>

    <!-- Manual Intervention Required Section -->
    <div class="section manual-intervention-section" id="manual-intervention-section">
        <h2>
            ‚ö†Ô∏è Manual Intervention Required
            <span class="count-badge error" id="count-failed">0</span>
            <a href="{{ url_for('auto_scheduler.export_review_category', run_id=run.id, category='failed') }}"
               class="btn-export" title="Export failed events to CSV">üì• Export</a>
        </h2>
        <div class="intervention-notice">
            <strong>These events could not be automatically scheduled and require manual assignment:</strong>
        </div>
        <div id="failed-container">
            <div class="loading">
                <div class="loading-spinner"></div>
                <p>Loading events requiring manual scheduling...</p>
            </div>
        </div>
    </div>

    <!-- Newly Scheduled Events Section -->
    <div class="section">
        <h2>
            Newly Scheduled Events
            <span class="count-badge" id="count-scheduled">0</span>
            <a href="{{ url_for('auto_scheduler.export_review_category', run_id=run.id, category='newly_scheduled') }}"
               class="btn-export" title="Export newly scheduled events to CSV">üì• Export</a>
        </h2>
        <div id="newly-scheduled-container">
            <div class="loading">
                <div class="loading-spinner"></div>
                <p>Loading proposed schedules...</p>
            </div>
        </div>
    </div>

    <!-- Events Being Bumped Section -->
    <div class="section">
        <h2>
            Events Being Bumped
            <span class="count-badge" id="count-swaps">0</span>
            <a href="{{ url_for('auto_scheduler.export_review_category', run_id=run.id, category='swaps') }}"
               class="btn-export" title="Export bumped events to CSV">üì• Export</a>
        </h2>
        <div id="swaps-container">
            <div class="loading">
                <div class="loading-spinner"></div>
                <p>Loading swap proposals...</p>
            </div>
        </div>
    </div>

    <!-- Daily Preview Section -->
    <div class="section">
        <h2>Daily Preview</h2>

        <!-- Legend -->
        <div class="schedule-legend">
            <h4>Schedule Legend</h4>
            <div class="legend-items">
                <div class="legend-item">
                    <div class="legend-color proposed"></div>
                    <span>Newly Proposed</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color swap"></div>
                    <span>Bump (Replacing Another Event)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color existing"></div>
                    <span>Already Scheduled</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color bumped"></div>
                    <span>Being Bumped (Will Be Moved)</span>
                </div>
            </div>
        </div>

        <div id="daily-preview-container" class="daily-preview">
            <div class="loading">
                <div class="loading-spinner"></div>
                <p>Loading daily preview...</p>
            </div>
        </div>
    </div>

    <!-- Action Buttons -->
    <div class="action-buttons">
        <button type="button" class="btn-approve" id="approve-button" disabled>
            Approve Schedule
        </button>
        <button type="button" class="btn-reject" id="reject-button">
            Reject & Return to Dashboard
        </button>
    </div>

    {% else %}
    <div class="review-header">
        <h1>No Pending Proposals</h1>
        <div class="empty-state">
            <div class="icon">üìÖ</div>
            <p>{{ message or "There are no pending schedule proposals to review." }}</p>
            <p><a href="{{ url_for('main.dashboard') }}">Return to Dashboard</a></p>
        </div>
    </div>
    {% endif %}

    <!-- Edit Pending Schedule Modal -->
    <div class="edit-modal-overlay" id="edit-pending-modal">
        <div class="edit-modal">
            <h3>Edit Proposed Schedule</h3>
            <form id="edit-pending-form">
                <input type="hidden" id="edit-pending-id">
                <input type="hidden" id="edit-event-type">
                <input type="hidden" id="edit-event-ref-num">

                <div class="event-info" id="edit-event-info">
                    <!-- Event info will be populated by JS -->
                </div>

                <div class="form-group">
                    <label for="edit-employee">Assign to Employee:</label>
                    <select id="edit-employee" required>
                        <option value="">Loading employees...</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="edit-date">Schedule Date:</label>
                    <input type="date" id="edit-date" required>
                </div>

                <div class="form-group">
                    <label for="edit-time">Schedule Time:</label>
                    <input type="time" id="edit-time" required>
                </div>

                <div class="modal-actions">
                    <button type="button" class="btn-cancel" data-action="close-edit-pending-modal">Cancel</button>
                    <button type="submit" class="btn-save">Save Changes</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Progress Modal -->
    <div class="progress-modal-overlay" id="progress-modal">
        <div class="progress-modal">
            <h2>Approving Schedule...</h2>
            <div class="progress-info">
                <div class="progress-label">Processing Events</div>
                <div class="progress-count" id="progress-count">0 / 0</div>
            </div>
            <div class="progress-bar-container">
                <div class="progress-bar" id="progress-bar" style="width: 0%;">
                    <span id="progress-percentage">0%</span>
                </div>
            </div>
            <div class="progress-current-event" id="current-event">
                Initializing...
            </div>
            <div id="progress-status"></div>
        </div>
    </div>

    <!-- Manual Schedule Modal for Failed Events -->
    <div class="edit-modal-overlay" id="manual-schedule-modal">
        <div class="edit-modal">
            <h3>üìÖ Schedule Event</h3>
            <form id="manual-schedule-form">
                <input type="hidden" id="manual-event-ref-num">
                <input type="hidden" id="manual-event-type">
                <input type="hidden" id="manual-event-id">

                <div class="event-info" id="manual-event-info">
                    <!-- Event info will be populated by JS -->
                </div>

                <div class="form-group">
                    <label for="manual-date">Schedule Date:</label>
                    <input type="date" id="manual-date" required>
                    <small id="manual-date-hint" class="form-hint"></small>
                </div>

                <div class="form-group">
                    <label for="manual-time">Schedule Time:</label>
                    <select id="manual-time" required>
                        <option value="">Select a date first</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="manual-employee">Assign to Employee:</label>
                    <select id="manual-employee" required>
                        <option value="">Select a date and time first</option>
                    </select>
                    <div id="manual-employee-loading" class="loading-spinner" style="display: none;">Loading eligible
                        employees...</div>
                </div>

                <div id="manual-validation-message" class="validation-message" style="display: none;"></div>

                <div class="modal-actions">
                    <button type="button" class="btn-cancel" data-action="close-manual-schedule-modal">Cancel</button>
                    <button type="submit" class="btn-save" id="manual-submit-btn" disabled>Schedule Event</button>
                </div>
            </form>
        </div>
    </div>
</div>

<script>
    function escapeHtml(text) {
        if (text == null) return '';
        return String(text).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#039;');
    }

    document.addEventListener('DOMContentLoaded', async function () {
        {% if run %}
        const runId = {{ run.id }};
    const messageContainer = document.getElementById('message-container');

    // Store raw schedule data for each pending item for easy retrieval
    let pendingSchedulesData = {};

    // After loading data, store it for edit modal use
    function storePendingData(newlyScheduled, swaps) {
        pendingSchedulesData = {};
        [...newlyScheduled, ...swaps].forEach(item => {
            pendingSchedulesData[item.id] = item;
        });
    }

    // Store raw failed events data for manual scheduling modal
    let failedEventsData = {};

    function storeFailedEventsData(failedEvents) {
        failedEventsData = {};
        failedEvents.forEach(event => {
            failedEventsData[event.event_ref_num] = event;
        });
    }

    function showMessage(message, type = 'success') {
        const alertDiv = document.createElement('div');
        alertDiv.className = `alert alert-${type}`;
        alertDiv.textContent = message;
        messageContainer.appendChild(alertDiv);

        setTimeout(() => {
            alertDiv.remove();
        }, 5000);
    }

    function getEventTypeBadge(eventType) {
        const typeClass = escapeHtml(eventType).toLowerCase().replace(/\s+/g, '-');
        return `<span class="event-type-badge event-type-${typeClass}">${escapeHtml(eventType)}</span>`;
    }

    function formatDateTime(dateString, timeString) {
        if (!dateString) return '-';

        // Parse date as local time to avoid timezone issues
        // dateString format: "YYYY-MM-DD" or "YYYY-MM-DDTHH:MM:SS"
        const parts = dateString.split('T')[0].split('-');
        const year = parseInt(parts[0]);
        const month = parseInt(parts[1]) - 1; // Month is 0-indexed
        const day = parseInt(parts[2]);
        const date = new Date(year, month, day);

        const formatted = date.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' });
        return timeString ? `${formatted} at ${timeString}` : formatted;
    }

    function formatEventPeriod(startDate, endDate) {
        if (!startDate || !endDate) return '-';
        const formatShort = (dateStr) => {
            const parts = dateStr.split('-');
            const d = new Date(parseInt(parts[0]), parseInt(parts[1]) - 1, parseInt(parts[2]));
            return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
        };
        return `${formatShort(startDate)} - ${formatShort(endDate)}`;
    }

    // Run schedule verification first
    try {
        const verifyResponse = await fetch(`/auto-schedule/api/verify/${runId}`);
        if (verifyResponse.ok) {
            const verifyData = await verifyResponse.json();
            displayVerificationResults(verifyData);
        }
    } catch (error) {
        console.error('Verification failed:', error);
    }

    // Load pending schedules
    try {
        const response = await fetch('{{ url_for("auto_scheduler.get_pending_schedules") }}?run_id=' + runId);

        if (!response.ok) {
            const error = await response.json();
            showMessage('Error loading pending schedules: ' + (error.error || 'Unknown error'), 'error');
            return;
        }

        const data = await response.json();

        // Update stats - use actual list lengths for accurate breakdown
        document.getElementById('stat-scheduled').textContent = data.newly_scheduled.length;
        document.getElementById('stat-swaps').textContent = data.swaps.length;
        document.getElementById('stat-failed').textContent = data.failed.length;
        // Total = newly scheduled + bumps + failed
        const totalActual = data.newly_scheduled.length + data.swaps.length + data.failed.length;
        document.getElementById('stat-total').textContent = totalActual;

        // Update count badges
        document.getElementById('count-scheduled').textContent = data.newly_scheduled.length;
        document.getElementById('count-swaps').textContent = data.swaps.length;
        document.getElementById('count-failed').textContent = data.failed.length;

        // Store pending data for edit modal
        storePendingData(data.newly_scheduled, data.swaps);

        // Render newly scheduled
        const scheduledContainer = document.getElementById('newly-scheduled-container');
        if (data.newly_scheduled.length === 0) {
            scheduledContainer.innerHTML = '<div class="empty-state">No events newly scheduled in this run.</div>';
        } else {
            let html = '<table class="event-table" aria-describedby="newly-scheduled-desc">';
            html += '<caption id="newly-scheduled-desc" class="sr-only">List of events newly scheduled by the auto-scheduler, showing event details and assigned employees</caption>';
            html += '<thead><tr><th scope="col">Event</th><th scope="col">Type</th><th scope="col">Event Period</th><th scope="col">Assigned To</th><th scope="col">Scheduled For</th><th scope="col">Actions</th></tr></thead><tbody>';
            data.newly_scheduled.forEach(event => {
                html += `<tr>
                    <td>${escapeHtml(event.event_name)}</td>
                    <td>${getEventTypeBadge(event.event_type)}</td>
                    <td>${formatEventPeriod(event.start_date, event.end_date)}</td>
                    <td>${escapeHtml(event.employee_name)}</td>
                    <td>${formatDateTime(event.schedule_date, event.schedule_time)}</td>
                    <td><button class="btn-edit" data-pending-id="${event.id}">Edit</button></td>
                </tr>`;
            });
            html += '</tbody></table>';
            scheduledContainer.innerHTML = html;
        }

        // Render bumps (previously called swaps)
        const swapsContainer = document.getElementById('swaps-container');
        if (data.swaps.length === 0) {
            swapsContainer.innerHTML = '<div class="empty-state">No events being bumped in this run.</div>';
        } else {
            // Helper function to strip 6-digit number from event name (since we show it separately)
            function stripEventNumber(name, number) {
                if (!name || !number) return name;
                // Remove the 6-digit number and any following dash/hyphen with spaces
                return name.replace(new RegExp(number + '[-‚Äì]?\\s*', 'g'), '').trim();
            }
            
            let html = '<table class="event-table bump-table" aria-describedby="bumped-events-desc">';
            html += '<caption id="bumped-events-desc" class="sr-only">List of events being replaced by higher priority events, showing original and replacement details</caption>';
            html += '<thead><tr><th scope="col">Event Being Bumped</th><th scope="col">Replaced By</th><th scope="col">New Schedule</th><th scope="col">Bumped Event Rescheduled To</th><th scope="col">Actions</th></tr></thead><tbody>';
            data.swaps.forEach(event => {
                // Format the bumped event info (show number once, then name without number)
                const bumpedNameClean = stripEventNumber(event.bumped_event_name, event.bumped_event_number);
                const bumpedEventDisplay = event.bumped_event_number
                    ? `<strong>${escapeHtml(event.bumped_event_number)}</strong> - ${escapeHtml(bumpedNameClean) || 'Unknown'}`
                    : escapeHtml(event.bumped_event_name) || 'Unknown';

                // Format the replacing event info (show number once, then name without number)
                const replacingNameClean = stripEventNumber(event.event_name, event.replacing_event_number);
                const replacingEventDisplay = event.replacing_event_number
                    ? `<strong>${escapeHtml(event.replacing_event_number)}</strong> - ${escapeHtml(replacingNameClean)}`
                    : escapeHtml(event.event_name);

                // Format the new schedule for the replacing event
                const newScheduleDisplay = `${escapeHtml(event.employee_name)}<br>${formatDateTime(event.schedule_date, event.schedule_time)}`;
                
                // Format where the bumped event is being rescheduled to
                let rescheduledToDisplay;
                if (event.bumped_rescheduled_to) {
                    if (event.bumped_rescheduled_to.failed) {
                        // Show failure reason in red
                        rescheduledToDisplay = `<span class="text-danger">Failed: ${escapeHtml(event.bumped_rescheduled_to.failure_reason)}</span>`;
                    } else {
                        // Show successful reschedule
                        rescheduledToDisplay = `${escapeHtml(event.bumped_rescheduled_to.employee_name)}<br>${formatDateTime(event.bumped_rescheduled_to.schedule_date, event.bumped_rescheduled_to.schedule_time)}`;
                    }
                } else {
                    // This should never happen - scheduler always reschedules or fails
                    rescheduledToDisplay = '<span class="text-danger">Error: Not processed</span>';
                }
                
                html += `<tr>
                    <td>${bumpedEventDisplay}</td>
                    <td>${replacingEventDisplay}</td>
                    <td>${newScheduleDisplay}</td>
                    <td>${rescheduledToDisplay}</td>
                    <td><button class="btn-edit" data-pending-id="${event.id}">Edit</button></td>
                </tr>`;
            });
            html += '</tbody></table>';
            swapsContainer.innerHTML = html;
        }

        // Render daily preview
        const dailyContainer = document.getElementById('daily-preview-container');
        const sortedDates = Object.keys(data.daily_preview).sort();
        if (sortedDates.length === 0) {
            dailyContainer.innerHTML = '<div class="empty-state">No scheduled events to preview.</div>';
        } else {
            let html = '';
            sortedDates.forEach(dateStr => {
                const events = data.daily_preview[dateStr];

                // Parse date as local time to avoid timezone issues
                const parts = dateStr.split('-');
                const year = parseInt(parts[0]);
                const month = parseInt(parts[1]) - 1;
                const day = parseInt(parts[2]);
                const date = new Date(year, month, day);

                const formatted = date.toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric' });

                html += `<div class="day-card">
                    <h4>${formatted}</h4>`;

                // Sort events by time
                const sortedEvents = events.sort((a, b) => {
                    if (!a.schedule_time) return 1;
                    if (!b.schedule_time) return -1;
                    return a.schedule_time.localeCompare(b.schedule_time);
                });

                sortedEvents.forEach(event => {
                    const statusClass = event.status ? `status-${event.status}` : '';
                    const statusLabel = event.status === 'proposed' ? 'NEW' :
                        event.status === 'swap' ? 'SWAP' :
                            event.status === 'existing' ? 'EXISTING' :
                                event.status === 'bumped_from' ? 'BUMPED' : '';
                    const statusBadgeClass = event.status === 'bumped_from' ? 'bumped' : event.status;

                    html += `<div class="event-item ${statusClass}">
                        <div class="time">${event.schedule_time || '-'}${statusLabel ? `<span class="status-badge ${statusBadgeClass}">${statusLabel}</span>` : ''}</div>
                        <div>${escapeHtml(event.event_name)}</div>
                        <div class="employee">${escapeHtml(event.employee_name)}</div>
                    </div>`;
                });
                html += '</div>';
            });
            dailyContainer.innerHTML = html;
        }

        // Render failed events and show/hide manual intervention section
        const failedContainer = document.getElementById('failed-container');
        const manualInterventionSection = document.getElementById('manual-intervention-section');

        if (data.failed.length === 0) {
            // Hide the entire manual intervention section if no failures
            manualInterventionSection.style.display = 'none';
        } else {
            // Store failed events data for the modal
            storeFailedEventsData(data.failed);

            // Show the section and render failed events
            manualInterventionSection.style.display = 'block';
            let html = '<table class="event-table" aria-describedby="failed-events-desc">';
            html += '<caption id="failed-events-desc" class="sr-only">List of events that could not be automatically scheduled and require manual intervention</caption>';
            html += '<thead><tr><th scope="col">Event</th><th scope="col">Type</th><th scope="col">Event Period</th><th scope="col">Failure Reason</th><th scope="col">Action</th></tr></thead><tbody>';
            data.failed.forEach(event => {
                html += `<tr>
                    <td><strong>${escapeHtml(event.event_name)}</strong></td>
                    <td>${getEventTypeBadge(event.event_type)}</td>
                    <td>${formatEventPeriod(event.start_date, event.end_date)}</td>
                    <td class="failure-reason">${escapeHtml(event.failure_reason) || 'Unknown error'}</td>
                    <td><button class="btn-edit btn-manual-schedule" data-event-ref="${escapeHtml(event.event_ref_num)}">Schedule</button></td>
                </tr>`;
            });
            html += '</tbody></table>';
            failedContainer.innerHTML = html;
        }

        // Enable approve button if there are schedules to approve
        if (data.newly_scheduled.length > 0 || data.swaps.length > 0) {
            document.getElementById('approve-button').disabled = false;
        }

    } catch (error) {
        showMessage('Failed to load pending schedules: ' + error.message, 'error');
    }

    // Approve button handler with progress tracking
    document.getElementById('approve-button').addEventListener('click', async function () {
        if (!confirm('Approve this schedule and create all assignments? This action cannot be undone.')) {
            return;
        }

        // Disable the approve button
        this.disabled = true;
        const originalText = this.textContent;

        // Get the progress modal elements
        const progressModal = document.getElementById('progress-modal');
        const progressCount = document.getElementById('progress-count');
        const progressBar = document.getElementById('progress-bar');
        const progressPercentage = document.getElementById('progress-percentage');
        const currentEventDisplay = document.getElementById('current-event');
        const progressStatus = document.getElementById('progress-status');

        try {
            // Fetch all pending schedules to process
            const pendingResponse = await fetch('{{ url_for("auto_scheduler.get_pending_schedules") }}?run_id=' + runId);
            if (!pendingResponse.ok) {
                throw new Error('Failed to fetch pending schedules');
            }

            const pendingData = await pendingResponse.json();

            // Get all non-failed schedules to approve
            const schedulesToApprove = [
                ...pendingData.newly_scheduled,
                ...pendingData.swaps
            ];

            const totalCount = schedulesToApprove.length;

            if (totalCount === 0) {
                showMessage('No schedules to approve', 'warning');
                this.disabled = false;
                return;
            }

            // Show the progress modal
            progressModal.classList.add('active');
            progressCount.textContent = `0 / ${totalCount}`;
            progressBar.style.width = '0%';
            progressPercentage.textContent = '0%';
            currentEventDisplay.textContent = 'Starting approval process...';
            progressStatus.innerHTML = '';

            let successCount = 0;
            let failureCount = 0;
            const failures = [];

            // Process each schedule one at a time
            for (let i = 0; i < schedulesToApprove.length; i++) {
                const schedule = schedulesToApprove[i];
                const currentNum = i + 1;

                // Update progress display
                progressCount.textContent = `${currentNum} / ${totalCount}`;
                currentEventDisplay.textContent = 'Scheduling: ' + schedule.event_name + ' \u2192 ' + schedule.employee_name;

                try {
                    // Call the approve-single endpoint
                    const approveResponse = await fetch(`/auto-schedule/approve-single/${schedule.id}`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        }
                    });

                    const approveData = await approveResponse.json();

                    if (approveData.success) {
                        successCount++;
                    } else {
                        failureCount++;
                        failures.push({
                            event_name: schedule.event_name,
                            employee_name: schedule.employee_name,
                            error: approveData.error
                        });
                    }
                } catch (error) {
                    failureCount++;
                    failures.push({
                        event_name: schedule.event_name,
                        employee_name: schedule.employee_name,
                        error: error.message
                    });
                }

                // Update progress bar
                const percentage = Math.round((currentNum / totalCount) * 100);
                progressBar.style.width = `${percentage}%`;
                progressPercentage.textContent = `${percentage}%`;
            }

            // Mark the run as approved
            await fetch(`/auto-schedule/mark-approved/${runId}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                }
            });

            // Show final status
            currentEventDisplay.textContent = 'All schedules processed!';

            let statusHtml = `<div class="progress-status ${failureCount > 0 ? 'warning' : 'success'}">`;
            statusHtml += `<strong>Approval Complete:</strong><br>`;
            statusHtml += `‚úì ${successCount} schedules submitted successfully<br>`;
            if (failureCount > 0) {
                statusHtml += `‚úó ${failureCount} schedules failed<br>`;
                statusHtml += `<div class="progress-details">`;
                failures.forEach(f => {
                    statusHtml += `<div class="progress-detail-item error">`;
                    statusHtml += `${escapeHtml(f.event_name)} \u2192 ${escapeHtml(f.employee_name)}: ${escapeHtml(f.error)}`;
                    statusHtml += `</div>`;
                });
                statusHtml += `</div>`;
            }
            statusHtml += `<br><button data-action="return-to-dashboard" class="btn-approve">Return to Dashboard</button>`;
            statusHtml += `</div>`;

            progressStatus.innerHTML = statusHtml;

        } catch (error) {
            showMessage('Failed to approve schedules: ' + error.message, 'error');
            this.disabled = false;
            this.textContent = originalText;
            progressModal.classList.remove('active');
        }
    });

    // Reject button handler
    document.getElementById('reject-button').addEventListener('click', async function () {
        if (!confirm('Reject ALL pending schedule proposals and return to dashboard? All proposed schedules will be permanently discarded.')) {
            return;
        }

        try {
            const response = await fetch('{{ url_for("auto_scheduler.reject_schedule") }}', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    reject_all: true
                })
            });

            const data = await response.json();

            if (response.ok && data.success) {
                showMessage(data.message, 'success');
                setTimeout(() => {
                    window.location.href = '{{ url_for("main.dashboard") }}';
                }, 1500);
            } else {
                showMessage('Error rejecting proposals: ' + (data.error || 'Unknown error'), 'error');
            }
        } catch (error) {
            showMessage('Failed to reject proposals: ' + error.message, 'error');
        }
    });

    // ============================================================
    // Edit Pending Schedule Modal Functions
    // ============================================================

    function openEditPendingModal(pendingId) {
        const data = pendingSchedulesData[pendingId];
        if (!data) {
            showMessage('Could not find schedule data', 'error');
            return;
        }

        // Populate hidden fields
        document.getElementById('edit-pending-id').value = pendingId;
        document.getElementById('edit-event-type').value = data.event_type;
        document.getElementById('edit-event-ref-num').value = data.event_ref_num;

        // Populate event info
        document.getElementById('edit-event-info').innerHTML = `
            <strong>${escapeHtml(data.event_name)}</strong><br>
            <small>Type: ${escapeHtml(data.event_type)} | Ref: ${escapeHtml(data.event_ref_num)}</small>
        `;

        // Set current date and time
        if (data.schedule_date) {
            document.getElementById('edit-date').value = data.schedule_date;
        }
        if (data.schedule_time) {
            document.getElementById('edit-time').value = data.schedule_time;
        }

        // Load available employees
        loadEmployeesForEdit(data.schedule_date, data.event_type, data.employee_id);

        // Show modal
        document.getElementById('edit-pending-modal').classList.add('active');
    }

    function closeEditPendingModal() {
        document.getElementById('edit-pending-modal').classList.remove('active');
        document.getElementById('edit-pending-form').reset();
    }

    async function loadEmployeesForEdit(date, eventType, currentEmployeeId) {
        const select = document.getElementById('edit-employee');
        select.innerHTML = '<option value="">Loading employees...</option>';

        try {
            // Use the role-filtered endpoint if date and event type are available
            let apiUrl = '/api/employees';
            if (date && eventType) {
                apiUrl = `/api/available_employees_for_change/${date}/${encodeURIComponent(eventType)}`;
                if (currentEmployeeId) {
                    apiUrl += `?current_employee_id=${currentEmployeeId}&current_date=${date}`;
                }
            }

            const response = await fetch(apiUrl);
            const employees = await response.json();

            select.innerHTML = '<option value="">Select an employee...</option>';

            // Handle both response formats (array directly or with filtering)
            const employeeList = Array.isArray(employees) ? employees : (employees.employees || []);

            employeeList
                .filter(emp => emp.is_active !== false)  // Filter active if property exists
                .forEach(emp => {
                    const option = document.createElement('option');
                    option.value = emp.id;
                    option.textContent = emp.job_title ? `${emp.name} (${emp.job_title})` : emp.name;
                    if (String(emp.id) === String(currentEmployeeId)) {
                        option.selected = true;
                    }
                    select.appendChild(option);
                });
        } catch (error) {
            console.error('Error loading employees:', error);
            select.innerHTML = '<option value="">Error loading employees</option>';
        }
    }

    // Edit form submission
    document.getElementById('edit-pending-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const pendingId = document.getElementById('edit-pending-id').value;
        const employeeId = document.getElementById('edit-employee').value;
        const date = document.getElementById('edit-date').value;
        const time = document.getElementById('edit-time').value;

        if (!employeeId || !date || !time) {
            showMessage('Please fill in all fields', 'error');
            return;
        }

        // Combine date and time into ISO datetime
        const scheduleDatetime = `${date}T${time}:00`;

        const saveBtn = this.querySelector('.btn-save');
        const originalText = saveBtn.textContent;
        saveBtn.disabled = true;
        saveBtn.textContent = 'Saving...';

        try {
            const response = await fetch(`/auto-schedule/api/pending/${pendingId}`, {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    employee_id: employeeId,
                    schedule_datetime: scheduleDatetime
                })
            });

            const result = await response.json();

            if (result.success) {
                showMessage('Schedule updated successfully', 'success');
                closeEditPendingModal();

                // Reload the page to reflect changes
                // (Could also update the table row inline for better UX)
                setTimeout(() => {
                    location.reload();
                }, 1000);
            } else {
                showMessage('Error: ' + (result.error || 'Failed to update schedule'), 'error');
            }
        } catch (error) {
            showMessage('Failed to update schedule: ' + error.message, 'error');
        } finally {
            saveBtn.disabled = false;
            saveBtn.textContent = originalText;
        }
    });

    // Click handler for edit buttons
    document.addEventListener('click', function (e) {
        if (e.target.classList.contains('btn-edit') && e.target.dataset.pendingId) {
            openEditPendingModal(e.target.dataset.pendingId);
        }
    });

    // Display verification results
    function displayVerificationResults(data) {
        const section = document.getElementById('verification-section');
        const icon = document.getElementById('verification-icon');
        const badge = document.getElementById('verification-badge');
        const content = document.getElementById('verification-content');
        const approveButton = document.getElementById('approve-button');

        section.style.display = 'block';

        const criticalCount = data.critical_issues ? data.critical_issues.length : 0;
        const warningCount = data.warnings ? data.warnings.length : 0;
        const infoCount = data.info ? data.info.length : 0;

        // Update badge and icon
        if (criticalCount > 0) {
            icon.textContent = '‚ùå';
            badge.textContent = `${criticalCount} Critical Issues`;
            badge.className = 'count-badge error';
            badge.style.background = 'var(--color-danger)';

            // Disable approve button
            approveButton.disabled = true;
            approveButton.title = 'Cannot approve: Critical issues must be resolved';
        } else if (warningCount > 0) {
            icon.textContent = '‚ö†Ô∏è';
            badge.textContent = `${warningCount} Warnings`;
            badge.className = 'count-badge warning';
            badge.style.background = 'var(--color-warning)';
        } else {
            icon.textContent = '‚úÖ';
            badge.textContent = 'All Checks Passed';
            badge.className = 'count-badge success';
            badge.style.background = 'var(--color-success)';
        }

        // Build content HTML
        let html = '';

        // Critical issues
        if (criticalCount > 0) {
            html += '<div class="alert alert-error" style="margin-bottom: 20px;">';
            html += '<strong>‚õî Critical Issues (Must Fix Before Approval):</strong>';
            html += '<ul style="margin: 10px 0 0 20px;">';
            data.critical_issues.forEach(issue => {
                html += `<li><strong>${escapeHtml(issue.category)}:</strong> ${escapeHtml(issue.message)}`;
                if (issue.action) {
                    html += `<br><em>Action: ${escapeHtml(issue.action)}</em>`;
                }
                html += '</li>';
            });
            html += '</ul></div>';
        }

        // Warnings
        if (warningCount > 0) {
            html += '<div class="alert alert-warning" style="margin-bottom: 20px;">';
            html += '<strong>‚ö†Ô∏è Warnings (Review Before Approval):</strong>';
            html += '<ul style="margin: 10px 0 0 20px;">';
            data.warnings.forEach(warning => {
                html += `<li><strong>${escapeHtml(warning.category)}:</strong> ${escapeHtml(warning.message)}`;
                if (warning.action) {
                    html += `<br><em>Suggestion: ${escapeHtml(warning.action)}</em>`;
                }
                html += '</li>';
            });
            html += '</ul></div>';
        }

        // Info messages
        if (infoCount > 0 && criticalCount === 0 && warningCount === 0) {
            html += '<div class="alert alert-success" style="margin-bottom: 20px;">';
            html += '<strong>‚ÑπÔ∏è Information:</strong>';
            html += '<ul style="margin: 10px 0 0 20px;">';
            data.info.forEach(info => {
                html += `<li>${escapeHtml(info.message)}</li>`;
            });
            html += '</ul></div>';
        }

        // If all passed
        if (criticalCount === 0 && warningCount === 0 && (!data.info || infoCount === 0)) {
            html += '<div class="alert alert-success">';
            html += '‚úÖ All verification checks passed! Schedule is ready for approval.';
            html += '</div>';
        }

        content.innerHTML = html;
    }

    // ============================================================
    // Manual Schedule Modal Functions (for failed events)
    // ============================================================

    function openManualScheduleModal(eventRefNum) {
        const event = failedEventsData[eventRefNum];
        if (!event) {
            showMessage('Could not find event data', 'error');
            return;
        }

        // Populate hidden fields
        document.getElementById('manual-event-ref-num').value = event.event_ref_num;
        document.getElementById('manual-event-type').value = event.event_type;

        // Populate event info
        document.getElementById('manual-event-info').innerHTML = `
            <strong>${escapeHtml(event.event_name)}</strong><br>
            <small>Type: ${escapeHtml(event.event_type)} | Ref: ${escapeHtml(event.event_ref_num)}</small><br>
            <small style="color: var(--color-danger);">Failed: ${escapeHtml(event.failure_reason) || 'Unknown'}</small>
        `;

        // Set date constraints
        const dateInput = document.getElementById('manual-date');
        const dateHint = document.getElementById('manual-date-hint');

        if (event.start_date && event.end_date) {
            dateInput.min = event.start_date;
            dateInput.max = event.end_date;
            dateHint.textContent = `Valid dates: ${formatEventPeriod(event.start_date, event.end_date)}`;
        } else {
            dateInput.min = '';
            dateInput.max = '';
            dateHint.textContent = '';
        }

        // Reset form fields
        dateInput.value = event.start_date || '';
        document.getElementById('manual-time').innerHTML = '<option value="">Select a date first</option>';
        document.getElementById('manual-employee').innerHTML = '<option value="">Select a date and time first</option>';
        document.getElementById('manual-submit-btn').disabled = true;
        document.getElementById('manual-validation-message').style.display = 'none';

        // Load allowed times if date is set
        if (dateInput.value) {
            loadAllowedTimesForManual(event.event_type);
        }

        // Show modal
        document.getElementById('manual-schedule-modal').classList.add('active');
    }

    function closeManualScheduleModal() {
        document.getElementById('manual-schedule-modal').classList.remove('active');
    }

    async function loadAllowedTimesForManual(eventType) {
        const timeSelect = document.getElementById('manual-time');
        const dateInput = document.getElementById('manual-date');
        const selectedDate = dateInput ? dateInput.value : '';

        timeSelect.innerHTML = '<option value="">Loading times...</option>';

        try {
            let url = `/api/event-allowed-times/${encodeURIComponent(eventType)}`;
            if (selectedDate) {
                url += `?date=${encodeURIComponent(selectedDate)}`;
            }
            const response = await fetch(url);
            const data = await response.json();

            timeSelect.innerHTML = '<option value="">Select a time...</option>';

            if (data.allowed_times && data.allowed_times.length > 0) {
                // Use time_details if available (includes counts)
                if (data.time_details && data.time_details.length > 0) {
                    data.time_details.forEach(detail => {
                        const option = document.createElement('option');
                        option.value = detail.value;
                        option.textContent = detail.label; // e.g. "9:45 AM (2 scheduled)"
                        timeSelect.appendChild(option);
                    });
                } else {
                    // Fallback to allowed_times
                    data.allowed_times.forEach(time => {
                        const option = document.createElement('option');
                        option.value = time;
                        // Convert 24h to 12h for display
                        const [hours, minutes] = time.split(':');
                        const hour = parseInt(hours);
                        const ampm = hour >= 12 ? 'PM' : 'AM';
                        const displayHour = hour % 12 || 12;
                        option.textContent = `${displayHour}:${minutes} ${ampm}`;
                        timeSelect.appendChild(option);
                    });
                }
            } else {
                // Fallback: allow any time
                for (let h = 7; h <= 19; h++) {
                    ['00', '15', '30', '45'].forEach(m => {
                        const time = `${h.toString().padStart(2, '0')}:${m}`;
                        const option = document.createElement('option');
                        option.value = time;
                        const ampm = h >= 12 ? 'PM' : 'AM';
                        const displayHour = h % 12 || 12;
                        option.textContent = `${displayHour}:${m} ${ampm}`;
                        timeSelect.appendChild(option);
                    });
                }
            }
        } catch (error) {
            console.error('Error loading allowed times:', error);
            timeSelect.innerHTML = '<option value="">Error loading times</option>';
        }
    }

    async function loadEligibleEmployeesForManual() {
        const date = document.getElementById('manual-date').value;
        const time = document.getElementById('manual-time').value;
        const eventType = document.getElementById('manual-event-type').value;
        const employeeSelect = document.getElementById('manual-employee');
        const loadingDiv = document.getElementById('manual-employee-loading');

        if (!date || !time) {
            employeeSelect.innerHTML = '<option value="">Select a date and time first</option>';
            return;
        }

        employeeSelect.innerHTML = '<option value="">Loading employees...</option>';
        loadingDiv.style.display = 'block';

        try {
            // Use the role-filtered endpoint
            const response = await fetch(`/api/available_employees_for_change/${date}/${encodeURIComponent(eventType)}`);
            const data = await response.json();

            loadingDiv.style.display = 'none';
            employeeSelect.innerHTML = '<option value="">Select an employee...</option>';

            const employees = Array.isArray(data) ? data : (data.employees || []);

            if (employees.length === 0) {
                employeeSelect.innerHTML = '<option value="">No eligible employees available</option>';
            } else {
                employees
                    .filter(emp => emp.is_active !== false)
                    .forEach(emp => {
                        const option = document.createElement('option');
                        option.value = emp.id;
                        option.textContent = emp.job_title ? `${emp.name} (${emp.job_title})` : emp.name;
                        employeeSelect.appendChild(option);
                    });
            }
        } catch (error) {
            console.error('Error loading employees:', error);
            loadingDiv.style.display = 'none';
            employeeSelect.innerHTML = '<option value="">Error loading employees</option>';
        }

        updateManualSubmitButtonState();
    }

    function updateManualSubmitButtonState() {
        const date = document.getElementById('manual-date').value;
        const time = document.getElementById('manual-time').value;
        const employee = document.getElementById('manual-employee').value;
        const submitBtn = document.getElementById('manual-submit-btn');

        submitBtn.disabled = !(date && time && employee);
    }

    // Event listeners for manual schedule modal
    document.getElementById('manual-date').addEventListener('change', function () {
        const eventType = document.getElementById('manual-event-type').value;
        if (this.value && eventType) {
            loadAllowedTimesForManual(eventType);
        }
        // Reset employee when date changes
        document.getElementById('manual-employee').innerHTML = '<option value="">Select a time first</option>';
        updateManualSubmitButtonState();
    });

    document.getElementById('manual-time').addEventListener('change', function () {
        if (this.value) {
            loadEligibleEmployeesForManual();
        }
        updateManualSubmitButtonState();
    });

    document.getElementById('manual-employee').addEventListener('change', updateManualSubmitButtonState);

    // Form submission
    document.getElementById('manual-schedule-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const eventRefNum = document.getElementById('manual-event-ref-num').value;
        const employeeId = document.getElementById('manual-employee').value;
        const date = document.getElementById('manual-date').value;
        const time = document.getElementById('manual-time').value;
        const eventData = failedEventsData[eventRefNum];

        if (!employeeId || !date || !time) {
            showMessage('Please fill in all fields', 'error');
            return;
        }

        const submitBtn = document.getElementById('manual-submit-btn');
        const originalText = submitBtn.textContent;
        submitBtn.disabled = true;
        submitBtn.textContent = 'Scheduling...';

        try {
            // Combine date and time
            const scheduleDatetime = `${date}T${time}:00`;

            // Call the schedule-event API
            // Note: The API expects project_ref_num as event_id, not the internal database ID
            const response = await fetch('/api/schedule-event', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    employee_id: employeeId,
                    event_id: eventRefNum,  // Use project_ref_num directly
                    schedule_datetime: scheduleDatetime
                })
            });

            const result = await response.json();

            if (result.success) {
                showMessage('Event scheduled successfully!', 'success');
                closeManualScheduleModal();

                // Clean up the pending schedule record
                try {
                    await fetch(`/auto-schedule/api/pending/by-ref/${eventRefNum}`, {
                        method: 'DELETE'
                    });
                } catch (cleanupError) {
                    console.warn('Could not clean up pending schedule:', cleanupError);
                }

                // Reload the page to reflect changes
                setTimeout(() => {
                    location.reload();
                }, 1000);
            } else {
                const validationMsg = document.getElementById('manual-validation-message');
                validationMsg.textContent = result.error || 'Failed to schedule event';
                validationMsg.style.display = 'block';
                validationMsg.className = 'validation-message error';
            }
        } catch (error) {
            showMessage('Failed to schedule event: ' + error.message, 'error');
        } finally {
            submitBtn.disabled = false;
            submitBtn.textContent = originalText;
        }
    });

    // Click handler for manual schedule buttons
    document.addEventListener('click', function (e) {
        if (e.target.classList.contains('btn-manual-schedule') && e.target.dataset.eventRef) {
            openManualScheduleModal(e.target.dataset.eventRef);
        }
    });

    // Delegated click handler for data-action buttons
    document.addEventListener('click', function(e) {
        var target = e.target.closest('[data-action]');
        if (!target) return;
        var action = target.dataset.action;
        switch (action) {
            case 'close-edit-pending-modal':
                closeEditPendingModal();
                break;
            case 'close-manual-schedule-modal':
                closeManualScheduleModal();
                break;
            case 'return-to-dashboard':
                window.location.href = '{{ url_for("main.dashboard") }}';
                break;
        }
    });

    {% endif %}
});
</script>
{% endblock %}