{% extends "base.html" %}

{% block title %}Review Auto-Schedule Proposal - Product Connections{% endblock %}

{% block extra_head %}
<style>
    .review-container {
        max-width: 1400px;
        margin: 0 auto;
        padding: 20px;
    }

    .review-header {
        background: white;
        border-radius: 8px;
        padding: 30px;
        margin-bottom: 30px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .review-header h1 {
        color: #2c3e50;
        margin-bottom: 10px;
    }

    .review-stats {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 20px;
        margin-top: 20px;
    }

    .stat-card {
        background: #f8f9fa;
        border-left: 4px solid #3498db;
        padding: 15px;
        border-radius: 4px;
    }

    .stat-card.success {
        border-left-color: #27ae60;
    }

    .stat-card.warning {
        border-left-color: #f39c12;
    }

    .stat-card.error {
        border-left-color: #e74c3c;
    }

    .stat-card h3 {
        margin: 0 0 5px 0;
        font-size: 14px;
        color: #7f8c8d;
        text-transform: uppercase;
    }

    .stat-card .value {
        font-size: 32px;
        font-weight: bold;
        color: #2c3e50;
    }

    .section {
        background: white;
        border-radius: 8px;
        padding: 25px;
        margin-bottom: 25px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .section h2 {
        color: #2c3e50;
        margin-bottom: 20px;
        padding-bottom: 10px;
        border-bottom: 2px solid #3498db;
        display: flex;
        align-items: center;
        justify-content: space-between;
    }

    .section h2 .count-badge {
        background: #3498db;
        color: white;
        padding: 4px 12px;
        border-radius: 12px;
        font-size: 14px;
    }

    .event-table {
        width: 100%;
        border-collapse: collapse;
        margin-top: 15px;
    }

    .event-table th {
        background: #f8f9fa;
        padding: 12px;
        text-align: left;
        font-weight: 600;
        color: #34495e;
        border-bottom: 2px solid #dee2e6;
    }

    .event-table td {
        padding: 12px;
        border-bottom: 1px solid #dee2e6;
    }

    .event-table tr:hover {
        background: #f8f9fa;
    }

    .event-type-badge {
        display: inline-block;
        padding: 4px 8px;
        border-radius: 4px;
        font-size: 12px;
        font-weight: 600;
    }

    .event-type-juicer {
        background: #e8f5e9;
        color: #2e7d32;
    }

    .event-type-digital {
        background: #e3f2fd;
        color: #1565c0;
    }

    .event-type-core {
        background: #fff3e0;
        color: #e65100;
    }

    .event-type-supervisor {
        background: #f3e5f5;
        color: #6a1b9a;
    }

    .event-type-freeosk {
        background: #fce4ec;
        color: #c2185b;
    }

    .swap-indicator {
        color: #f39c12;
        font-weight: bold;
    }

    .failure-reason {
        color: #e74c3c;
        font-style: italic;
    }

    .daily-preview {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(280px, 1fr));
        gap: 15px;
        margin-top: 15px;
    }

    .day-card {
        background: #f8f9fa;
        border: 1px solid #dee2e6;
        border-radius: 6px;
        padding: 15px;
    }

    .day-card h4 {
        margin: 0 0 12px 0;
        color: #2c3e50;
        font-size: 16px;
        border-bottom: 1px solid #dee2e6;
        padding-bottom: 8px;
    }

    .day-card .event-item {
        padding: 8px;
        margin-bottom: 8px;
        background: white;
        border-radius: 4px;
        font-size: 13px;
        border-left: 4px solid #dee2e6;
    }

    /* Event status color coding */
    .day-card .event-item.status-proposed {
        background: #e8f5e9;
        border-left-color: #27ae60;
    }

    .day-card .event-item.status-swap {
        background: #e3f2fd;
        border-left-color: #2196f3;
    }

    .day-card .event-item.status-existing {
        background: #f5f5f5;
        border-left-color: #9e9e9e;
        opacity: 0.8;
    }

    .day-card .event-item.status-bumped_from {
        background: #fff3e0;
        border-left-color: #ff9800;
        text-decoration: line-through;
        opacity: 0.7;
    }

    .day-card .event-item .time {
        font-weight: bold;
        color: #3498db;
    }

    .day-card .event-item .employee {
        color: #7f8c8d;
    }

    /* Status badges */
    .status-badge {
        display: inline-block;
        padding: 2px 6px;
        border-radius: 3px;
        font-size: 10px;
        font-weight: bold;
        margin-left: 6px;
        text-transform: uppercase;
    }

    .status-badge.proposed {
        background: #27ae60;
        color: white;
    }

    .status-badge.swap {
        background: #2196f3;
        color: white;
    }

    .status-badge.existing {
        background: #9e9e9e;
        color: white;
    }

    .status-badge.bumped {
        background: #ff9800;
        color: white;
    }

    /* Legend for color coding */
    .schedule-legend {
        background: #f8f9fa;
        border: 1px solid #dee2e6;
        border-radius: 6px;
        padding: 15px;
        margin-bottom: 20px;
    }

    .schedule-legend h4 {
        margin: 0 0 10px 0;
        font-size: 14px;
        color: #2c3e50;
    }

    .legend-items {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 10px;
    }

    .legend-item {
        display: flex;
        align-items: center;
        font-size: 13px;
    }

    .legend-color {
        width: 30px;
        height: 20px;
        border-radius: 3px;
        margin-right: 8px;
        border-left: 4px solid;
    }

    .legend-color.proposed {
        background: #e8f5e9;
        border-left-color: #27ae60;
    }

    .legend-color.swap {
        background: #e3f2fd;
        border-left-color: #2196f3;
    }

    .legend-color.existing {
        background: #f5f5f5;
        border-left-color: #9e9e9e;
    }

    .legend-color.bumped {
        background: #fff3e0;
        border-left-color: #ff9800;
    }

    /* Manual Intervention Section */
    .manual-intervention-section {
        border: 2px solid #e74c3c !important;
        background: #fff5f5 !important;
    }

    .manual-intervention-section::before {
        background: linear-gradient(90deg, #e74c3c 0%, #c0392b 100%) !important;
    }

    .manual-intervention-section h2 {
        border-bottom-color: #e74c3c;
        color: #c0392b;
    }

    .manual-intervention-section .count-badge.error {
        background: #e74c3c;
    }

    .intervention-notice {
        background: #fff3cd;
        border: 1px solid #ffeaa7;
        border-left: 4px solid #f39c12;
        padding: 12px;
        border-radius: 4px;
        margin-bottom: 15px;
        color: #856404;
    }

    .action-buttons {
        display: flex;
        gap: 15px;
        margin-top: 30px;
        padding-top: 20px;
        border-top: 2px solid #dee2e6;
    }

    .btn-approve {
        background-color: #27ae60;
        color: white;
        border: none;
        padding: 15px 40px;
        border-radius: 4px;
        font-size: 16px;
        font-weight: bold;
        cursor: pointer;
        transition: background-color 0.3s;
    }

    .btn-approve:hover {
        background-color: #229954;
    }

    .btn-approve:disabled {
        background-color: #95a5a6;
        cursor: not-allowed;
    }

    .btn-reject {
        background-color: #e74c3c;
        color: white;
        border: none;
        padding: 15px 40px;
        border-radius: 4px;
        font-size: 16px;
        cursor: pointer;
        transition: background-color 0.3s;
    }

    .btn-reject:hover {
        background-color: #c0392b;
    }

    .btn-edit {
        background-color: #3498db;
        color: white;
        border: none;
        padding: 6px 12px;
        border-radius: 4px;
        font-size: 12px;
        cursor: pointer;
    }

    .btn-edit:hover {
        background-color: #2980b9;
    }

    /* Edit Pending Schedule Modal */
    .edit-modal-overlay {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.6);
        z-index: 2000;
        justify-content: center;
        align-items: center;
    }

    .edit-modal-overlay.active {
        display: flex;
    }

    .edit-modal {
        background: white;
        border-radius: 8px;
        padding: 30px;
        max-width: 500px;
        width: 90%;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    }

    .edit-modal h3 {
        margin: 0 0 20px 0;
        color: #2c3e50;
        font-size: 20px;
        border-bottom: 2px solid #3498db;
        padding-bottom: 10px;
    }

    .edit-modal .form-group {
        margin-bottom: 20px;
    }

    .edit-modal .form-group label {
        display: block;
        margin-bottom: 6px;
        font-weight: 600;
        color: #34495e;
    }

    .edit-modal .form-group input,
    .edit-modal .form-group select {
        width: 100%;
        padding: 10px 12px;
        border: 1px solid #ddd;
        border-radius: 4px;
        font-size: 14px;
        box-sizing: border-box;
    }

    .edit-modal .form-group input:focus,
    .edit-modal .form-group select:focus {
        outline: none;
        border-color: #3498db;
        box-shadow: 0 0 0 2px rgba(52, 152, 219, 0.2);
    }

    .edit-modal .event-info {
        background: #f8f9fa;
        padding: 12px;
        border-radius: 4px;
        margin-bottom: 20px;
        border-left: 4px solid #3498db;
    }

    .edit-modal .event-info strong {
        color: #2c3e50;
    }

    .edit-modal .modal-actions {
        display: flex;
        gap: 10px;
        justify-content: flex-end;
        margin-top: 25px;
        padding-top: 20px;
        border-top: 1px solid #eee;
    }

    .edit-modal .btn-cancel {
        background: #95a5a6;
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
    }

    .edit-modal .btn-cancel:hover {
        background: #7f8c8d;
    }

    .edit-modal .btn-save {
        background: #27ae60;
        color: white;
        border: none;
        padding: 10px 20px;
        border-radius: 4px;
        cursor: pointer;
        font-size: 14px;
        font-weight: 600;
    }

    .edit-modal .btn-save:hover {
        background: #229954;
    }

    .edit-modal .btn-save:disabled {
        background: #95a5a6;
        cursor: not-allowed;
    }

    .form-hint {
        display: block;
        margin-top: 4px;
        color: #6c757d;
        font-size: 0.85rem;
    }

    .validation-message {
        padding: 10px 15px;
        border-radius: 6px;
        margin-bottom: 15px;
        font-size: 0.9rem;
    }

    .validation-message.error {
        background: #fdecea;
        color: #c0392b;
        border: 1px solid #e74c3c;
    }

    .validation-message.success {
        background: #d4edda;
        color: #155724;
        border: 1px solid #28a745;
    }

    .loading-spinner {
        padding: 8px;
        color: #3498db;
        font-size: 0.9rem;
    }

    .btn-manual-schedule {
        background: #9b59b6 !important;
    }

    .btn-manual-schedule:hover {
        background: #8e44ad !important;
    }

    .empty-state {
        text-align: center;
        padding: 40px;
        color: #7f8c8d;
    }

    .empty-state .icon {
        font-size: 48px;
        margin-bottom: 15px;
    }

    .alert {
        padding: 15px;
        border-radius: 4px;
        margin-bottom: 20px;
    }

    .alert-success {
        background-color: #d4edda;
        border: 1px solid #c3e6cb;
        color: #155724;
    }

    .alert-error {
        background-color: #f8d7da;
        border: 1px solid #f5c6cb;
        color: #721c24;
    }

    .alert-warning {
        background-color: #fff3cd;
        border: 1px solid #ffeaa7;
        color: #856404;
    }

    #message-container {
        position: fixed;
        top: 80px;
        right: 20px;
        z-index: 1000;
        max-width: 400px;
    }

    .loading {
        text-align: center;
        padding: 40px;
        color: #7f8c8d;
    }

    .loading-spinner {
        border: 4px solid #f3f3f3;
        border-top: 4px solid #3498db;
        border-radius: 50%;
        width: 40px;
        height: 40px;
        animation: spin 1s linear infinite;
        margin: 0 auto 15px;
    }

    @keyframes spin {
        0% {
            transform: rotate(0deg);
        }

        100% {
            transform: rotate(360deg);
        }
    }

    /* Progress Modal Styles */
    .progress-modal-overlay {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.7);
        z-index: 2000;
        justify-content: center;
        align-items: center;
    }

    .progress-modal-overlay.active {
        display: flex;
    }

    .progress-modal {
        background: white;
        border-radius: 8px;
        padding: 40px;
        max-width: 500px;
        width: 90%;
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
    }

    .progress-modal h2 {
        margin: 0 0 20px 0;
        color: #2c3e50;
        border-bottom: none;
    }

    .progress-info {
        text-align: center;
        margin-bottom: 25px;
    }

    .progress-count {
        font-size: 36px;
        font-weight: bold;
        color: #3498db;
        margin: 10px 0;
    }

    .progress-label {
        font-size: 16px;
        color: #7f8c8d;
        margin-bottom: 5px;
    }

    .progress-current-event {
        font-size: 14px;
        color: #2c3e50;
        margin-top: 15px;
        padding: 10px;
        background: #f8f9fa;
        border-radius: 4px;
        min-height: 40px;
    }

    .progress-bar-container {
        width: 100%;
        height: 30px;
        background: #ecf0f1;
        border-radius: 15px;
        overflow: hidden;
        margin-bottom: 20px;
    }

    .progress-bar {
        height: 100%;
        background: linear-gradient(90deg, #3498db 0%, #2ecc71 100%);
        transition: width 0.3s ease;
        display: flex;
        align-items: center;
        justify-content: center;
        color: white;
        font-weight: bold;
        font-size: 14px;
    }

    .progress-status {
        margin-top: 20px;
        padding: 15px;
        border-radius: 4px;
    }

    .progress-status.success {
        background: #d4edda;
        color: #155724;
        border: 1px solid #c3e6cb;
    }

    .progress-status.error {
        background: #f8d7da;
        color: #721c24;
        border: 1px solid #f5c6cb;
    }

    .progress-status.warning {
        background: #fff3cd;
        color: #856404;
        border: 1px solid #ffeaa7;
    }

    .progress-details {
        margin-top: 15px;
        max-height: 200px;
        overflow-y: auto;
        font-size: 13px;
    }

    .progress-detail-item {
        padding: 5px 0;
        border-bottom: 1px solid #dee2e6;
    }

    .progress-detail-item:last-child {
        border-bottom: none;
    }

    .progress-detail-item.success {
        color: #27ae60;
    }

    .progress-detail-item.error {
        color: #e74c3c;
    }
</style>
{% endblock %}

{% block content %}
<div class="review-container">
    <div id="message-container"></div>

    {% if run %}
    <div class="review-header">
        <h1>Review Auto-Schedule Proposal</h1>
        <p>Review the proposed schedule changes below. You can edit individual assignments before approving.</p>

        <div class="review-stats" id="stats-container">
            <div class="stat-card success">
                <h3>Newly Scheduled</h3>
                <div class="value" id="stat-scheduled">-</div>
            </div>
            <div class="stat-card warning">
                <h3>Require Swaps</h3>
                <div class="value" id="stat-swaps">-</div>
            </div>
            <div class="stat-card error">
                <h3>Failed to Schedule</h3>
                <div class="value" id="stat-failed">-</div>
            </div>
            <div class="stat-card">
                <h3>Total Processed</h3>
                <div class="value" id="stat-total">-</div>
            </div>
        </div>
    </div>

    <!-- Schedule Verification Section -->
    <div class="section" id="verification-section" style="display: none;">
        <h2>
            <span id="verification-icon">üîç</span> Schedule Verification
            <span class="count-badge" id="verification-badge">Checking...</span>
        </h2>
        <div id="verification-content">
            <div class="loading">
                <div class="loading-spinner"></div>
                <p>Running schedule verification...</p>
            </div>
        </div>
    </div>

    <!-- Manual Intervention Required Section -->
    <div class="section manual-intervention-section" id="manual-intervention-section">
        <h2>
            ‚ö†Ô∏è Manual Intervention Required
            <span class="count-badge error" id="count-failed">0</span>
        </h2>
        <div class="intervention-notice">
            <strong>These events could not be automatically scheduled and require manual assignment:</strong>
        </div>
        <div id="failed-container">
            <div class="loading">
                <div class="loading-spinner"></div>
                <p>Loading events requiring manual scheduling...</p>
            </div>
        </div>
    </div>

    <!-- Newly Scheduled Events Section -->
    <div class="section">
        <h2>
            Newly Scheduled Events
            <span class="count-badge" id="count-scheduled">0</span>
        </h2>
        <div id="newly-scheduled-container">
            <div class="loading">
                <div class="loading-spinner"></div>
                <p>Loading proposed schedules...</p>
            </div>
        </div>
    </div>

    <!-- Events Requiring Swaps Section -->
    <div class="section">
        <h2>
            Events Requiring Swaps
            <span class="count-badge" id="count-swaps">0</span>
        </h2>
        <div id="swaps-container">
            <div class="loading">
                <div class="loading-spinner"></div>
                <p>Loading swap proposals...</p>
            </div>
        </div>
    </div>

    <!-- Daily Preview Section -->
    <div class="section">
        <h2>Daily Preview</h2>

        <!-- Legend -->
        <div class="schedule-legend">
            <h4>Schedule Legend</h4>
            <div class="legend-items">
                <div class="legend-item">
                    <div class="legend-color proposed"></div>
                    <span>Newly Proposed</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color swap"></div>
                    <span>Swap (Bumping Another Event)</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color existing"></div>
                    <span>Already Scheduled</span>
                </div>
                <div class="legend-item">
                    <div class="legend-color bumped"></div>
                    <span>Being Bumped (Will Be Moved)</span>
                </div>
            </div>
        </div>

        <div id="daily-preview-container" class="daily-preview">
            <div class="loading">
                <div class="loading-spinner"></div>
                <p>Loading daily preview...</p>
            </div>
        </div>
    </div>

    <!-- Action Buttons -->
    <div class="action-buttons">
        <button type="button" class="btn-approve" id="approve-button" disabled>
            Approve Schedule
        </button>
        <button type="button" class="btn-reject" id="reject-button">
            Reject & Return to Dashboard
        </button>
    </div>

    {% else %}
    <div class="review-header">
        <h1>No Pending Proposals</h1>
        <div class="empty-state">
            <div class="icon">üìÖ</div>
            <p>{{ message or "There are no pending schedule proposals to review." }}</p>
            <p><a href="{{ url_for('main.dashboard') }}">Return to Dashboard</a></p>
        </div>
    </div>
    {% endif %}

    <!-- Edit Pending Schedule Modal -->
    <div class="edit-modal-overlay" id="edit-pending-modal">
        <div class="edit-modal">
            <h3>Edit Proposed Schedule</h3>
            <form id="edit-pending-form">
                <input type="hidden" id="edit-pending-id">
                <input type="hidden" id="edit-event-type">
                <input type="hidden" id="edit-event-ref-num">

                <div class="event-info" id="edit-event-info">
                    <!-- Event info will be populated by JS -->
                </div>

                <div class="form-group">
                    <label for="edit-employee">Assign to Employee:</label>
                    <select id="edit-employee" required>
                        <option value="">Loading employees...</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="edit-date">Schedule Date:</label>
                    <input type="date" id="edit-date" required>
                </div>

                <div class="form-group">
                    <label for="edit-time">Schedule Time:</label>
                    <input type="time" id="edit-time" required>
                </div>

                <div class="modal-actions">
                    <button type="button" class="btn-cancel" onclick="closeEditPendingModal()">Cancel</button>
                    <button type="submit" class="btn-save">Save Changes</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Progress Modal -->
    <div class="progress-modal-overlay" id="progress-modal">
        <div class="progress-modal">
            <h2>Approving Schedule...</h2>
            <div class="progress-info">
                <div class="progress-label">Processing Events</div>
                <div class="progress-count" id="progress-count">0 / 0</div>
            </div>
            <div class="progress-bar-container">
                <div class="progress-bar" id="progress-bar" style="width: 0%;">
                    <span id="progress-percentage">0%</span>
                </div>
            </div>
            <div class="progress-current-event" id="current-event">
                Initializing...
            </div>
            <div id="progress-status"></div>
        </div>
    </div>

    <!-- Manual Schedule Modal for Failed Events -->
    <div class="edit-modal-overlay" id="manual-schedule-modal">
        <div class="edit-modal">
            <h3>üìÖ Schedule Event</h3>
            <form id="manual-schedule-form">
                <input type="hidden" id="manual-event-ref-num">
                <input type="hidden" id="manual-event-type">
                <input type="hidden" id="manual-event-id">

                <div class="event-info" id="manual-event-info">
                    <!-- Event info will be populated by JS -->
                </div>

                <div class="form-group">
                    <label for="manual-date">Schedule Date:</label>
                    <input type="date" id="manual-date" required>
                    <small id="manual-date-hint" class="form-hint"></small>
                </div>

                <div class="form-group">
                    <label for="manual-time">Schedule Time:</label>
                    <select id="manual-time" required>
                        <option value="">Select a date first</option>
                    </select>
                </div>

                <div class="form-group">
                    <label for="manual-employee">Assign to Employee:</label>
                    <select id="manual-employee" required>
                        <option value="">Select a date and time first</option>
                    </select>
                    <div id="manual-employee-loading" class="loading-spinner" style="display: none;">Loading eligible
                        employees...</div>
                </div>

                <div id="manual-validation-message" class="validation-message" style="display: none;"></div>

                <div class="modal-actions">
                    <button type="button" class="btn-cancel" onclick="closeManualScheduleModal()">Cancel</button>
                    <button type="submit" class="btn-save" id="manual-submit-btn" disabled>Schedule Event</button>
                </div>
            </form>
        </div>
    </div>
</div>

<script>
    document.addEventListener('DOMContentLoaded', async function () {
        {% if run %}
        const runId = {{ run.id }};
    const messageContainer = document.getElementById('message-container');

    // Store raw schedule data for each pending item for easy retrieval
    let pendingSchedulesData = {};

    // After loading data, store it for edit modal use
    function storePendingData(newlyScheduled, swaps) {
        pendingSchedulesData = {};
        [...newlyScheduled, ...swaps].forEach(item => {
            pendingSchedulesData[item.id] = item;
        });
    }

    // Store raw failed events data for manual scheduling modal
    let failedEventsData = {};

    function storeFailedEventsData(failedEvents) {
        failedEventsData = {};
        failedEvents.forEach(event => {
            failedEventsData[event.event_ref_num] = event;
        });
    }

    function showMessage(message, type = 'success') {
        const alertDiv = document.createElement('div');
        alertDiv.className = `alert alert-${type}`;
        alertDiv.textContent = message;
        messageContainer.appendChild(alertDiv);

        setTimeout(() => {
            alertDiv.remove();
        }, 5000);
    }

    function getEventTypeBadge(eventType) {
        const typeClass = eventType.toLowerCase().replace(/\s+/g, '-');
        return `<span class="event-type-badge event-type-${typeClass}">${eventType}</span>`;
    }

    function formatDateTime(dateString, timeString) {
        if (!dateString) return '-';

        // Parse date as local time to avoid timezone issues
        // dateString format: "YYYY-MM-DD" or "YYYY-MM-DDTHH:MM:SS"
        const parts = dateString.split('T')[0].split('-');
        const year = parseInt(parts[0]);
        const month = parseInt(parts[1]) - 1; // Month is 0-indexed
        const day = parseInt(parts[2]);
        const date = new Date(year, month, day);

        const formatted = date.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' });
        return timeString ? `${formatted} at ${timeString}` : formatted;
    }

    function formatEventPeriod(startDate, endDate) {
        if (!startDate || !endDate) return '-';
        const formatShort = (dateStr) => {
            const parts = dateStr.split('-');
            const d = new Date(parseInt(parts[0]), parseInt(parts[1]) - 1, parseInt(parts[2]));
            return d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
        };
        return `${formatShort(startDate)} - ${formatShort(endDate)}`;
    }

    // Run schedule verification first
    try {
        const verifyResponse = await fetch(`/auto-schedule/api/verify/${runId}`);
        if (verifyResponse.ok) {
            const verifyData = await verifyResponse.json();
            displayVerificationResults(verifyData);
        }
    } catch (error) {
        console.error('Verification failed:', error);
    }

    // Load pending schedules
    try {
        const response = await fetch('{{ url_for("auto_scheduler.get_pending_schedules") }}?run_id=' + runId);

        if (!response.ok) {
            const error = await response.json();
            showMessage('Error loading pending schedules: ' + (error.error || 'Unknown error'), 'error');
            return;
        }

        const data = await response.json();

        // Update stats
        document.getElementById('stat-scheduled').textContent = data.stats.events_scheduled;
        document.getElementById('stat-swaps').textContent = data.stats.events_requiring_swaps;
        document.getElementById('stat-failed').textContent = data.stats.events_failed;
        document.getElementById('stat-total').textContent = data.stats.total_events_processed;

        // Update count badges
        document.getElementById('count-scheduled').textContent = data.newly_scheduled.length;
        document.getElementById('count-swaps').textContent = data.swaps.length;
        document.getElementById('count-failed').textContent = data.failed.length;

        // Store pending data for edit modal
        storePendingData(data.newly_scheduled, data.swaps);

        // Render newly scheduled
        const scheduledContainer = document.getElementById('newly-scheduled-container');
        if (data.newly_scheduled.length === 0) {
            scheduledContainer.innerHTML = '<div class="empty-state">No events newly scheduled in this run.</div>';
        } else {
            let html = '<table class="event-table">';
            html += '<thead><tr><th>Event</th><th>Type</th><th>Event Period</th><th>Assigned To</th><th>Scheduled For</th><th>Actions</th></tr></thead><tbody>';
            data.newly_scheduled.forEach(event => {
                html += `<tr>
                    <td>${event.event_name}</td>
                    <td>${getEventTypeBadge(event.event_type)}</td>
                    <td>${formatEventPeriod(event.start_date, event.end_date)}</td>
                    <td>${event.employee_name}</td>
                    <td>${formatDateTime(event.schedule_date, event.schedule_time)}</td>
                    <td><button class="btn-edit" data-pending-id="${event.id}">Edit</button></td>
                </tr>`;
            });
            html += '</tbody></table>';
            scheduledContainer.innerHTML = html;
        }

        // Render swaps
        const swapsContainer = document.getElementById('swaps-container');
        if (data.swaps.length === 0) {
            swapsContainer.innerHTML = '<div class="empty-state">No swap proposals in this run.</div>';
        } else {
            let html = '<table class="event-table">';
            html += '<thead><tr><th>Event</th><th>Type</th><th>Event Period</th><th>Assigned To</th><th>Scheduled For</th><th>Swap Reason</th><th>Actions</th></tr></thead><tbody>';
            data.swaps.forEach(event => {
                html += `<tr>
                    <td>${event.event_name}</td>
                    <td>${getEventTypeBadge(event.event_type)}</td>
                    <td>${formatEventPeriod(event.start_date, event.end_date)}</td>
                    <td>${event.employee_name}</td>
                    <td>${formatDateTime(event.schedule_date, event.schedule_time)}</td>
                    <td class="swap-indicator">${event.swap_reason || 'Conflict resolution'}</td>
                    <td><button class="btn-edit" data-pending-id="${event.id}">Edit</button></td>
                </tr>`;
            });
            html += '</tbody></table>';
            swapsContainer.innerHTML = html;
        }

        // Render daily preview
        const dailyContainer = document.getElementById('daily-preview-container');
        const sortedDates = Object.keys(data.daily_preview).sort();
        if (sortedDates.length === 0) {
            dailyContainer.innerHTML = '<div class="empty-state">No scheduled events to preview.</div>';
        } else {
            let html = '';
            sortedDates.forEach(dateStr => {
                const events = data.daily_preview[dateStr];

                // Parse date as local time to avoid timezone issues
                const parts = dateStr.split('-');
                const year = parseInt(parts[0]);
                const month = parseInt(parts[1]) - 1;
                const day = parseInt(parts[2]);
                const date = new Date(year, month, day);

                const formatted = date.toLocaleDateString('en-US', { weekday: 'long', month: 'long', day: 'numeric' });

                html += `<div class="day-card">
                    <h4>${formatted}</h4>`;

                // Sort events by time
                const sortedEvents = events.sort((a, b) => {
                    if (!a.schedule_time) return 1;
                    if (!b.schedule_time) return -1;
                    return a.schedule_time.localeCompare(b.schedule_time);
                });

                sortedEvents.forEach(event => {
                    const statusClass = event.status ? `status-${event.status}` : '';
                    const statusLabel = event.status === 'proposed' ? 'NEW' :
                        event.status === 'swap' ? 'SWAP' :
                            event.status === 'existing' ? 'EXISTING' :
                                event.status === 'bumped_from' ? 'BUMPED' : '';
                    const statusBadgeClass = event.status === 'bumped_from' ? 'bumped' : event.status;

                    html += `<div class="event-item ${statusClass}">
                        <div class="time">${event.schedule_time || '-'}${statusLabel ? `<span class="status-badge ${statusBadgeClass}">${statusLabel}</span>` : ''}</div>
                        <div>${event.event_name}</div>
                        <div class="employee">${event.employee_name}</div>
                    </div>`;
                });
                html += '</div>';
            });
            dailyContainer.innerHTML = html;
        }

        // Render failed events and show/hide manual intervention section
        const failedContainer = document.getElementById('failed-container');
        const manualInterventionSection = document.getElementById('manual-intervention-section');

        if (data.failed.length === 0) {
            // Hide the entire manual intervention section if no failures
            manualInterventionSection.style.display = 'none';
        } else {
            // Store failed events data for the modal
            storeFailedEventsData(data.failed);

            // Show the section and render failed events
            manualInterventionSection.style.display = 'block';
            let html = '<table class="event-table">';
            html += '<thead><tr><th>Event</th><th>Type</th><th>Event Period</th><th>Failure Reason</th><th>Action</th></tr></thead><tbody>';
            data.failed.forEach(event => {
                html += `<tr>
                    <td><strong>${event.event_name}</strong></td>
                    <td>${getEventTypeBadge(event.event_type)}</td>
                    <td>${formatEventPeriod(event.start_date, event.end_date)}</td>
                    <td class="failure-reason">${event.failure_reason || 'Unknown error'}</td>
                    <td><button class="btn-edit btn-manual-schedule" data-event-ref="${event.event_ref_num}">Schedule</button></td>
                </tr>`;
            });
            html += '</tbody></table>';
            failedContainer.innerHTML = html;
        }

        // Enable approve button if there are schedules to approve
        if (data.newly_scheduled.length > 0 || data.swaps.length > 0) {
            document.getElementById('approve-button').disabled = false;
        }

    } catch (error) {
        showMessage('Failed to load pending schedules: ' + error.message, 'error');
    }

    // Approve button handler with progress tracking
    document.getElementById('approve-button').addEventListener('click', async function () {
        if (!confirm('Approve this schedule and create all assignments? This action cannot be undone.')) {
            return;
        }

        // Disable the approve button
        this.disabled = true;
        const originalText = this.textContent;

        // Get the progress modal elements
        const progressModal = document.getElementById('progress-modal');
        const progressCount = document.getElementById('progress-count');
        const progressBar = document.getElementById('progress-bar');
        const progressPercentage = document.getElementById('progress-percentage');
        const currentEventDisplay = document.getElementById('current-event');
        const progressStatus = document.getElementById('progress-status');

        try {
            // Fetch all pending schedules to process
            const pendingResponse = await fetch('{{ url_for("auto_scheduler.get_pending_schedules") }}?run_id=' + runId);
            if (!pendingResponse.ok) {
                throw new Error('Failed to fetch pending schedules');
            }

            const pendingData = await pendingResponse.json();

            // Get all non-failed schedules to approve
            const schedulesToApprove = [
                ...pendingData.newly_scheduled,
                ...pendingData.swaps
            ];

            const totalCount = schedulesToApprove.length;

            if (totalCount === 0) {
                showMessage('No schedules to approve', 'warning');
                this.disabled = false;
                return;
            }

            // Show the progress modal
            progressModal.classList.add('active');
            progressCount.textContent = `0 / ${totalCount}`;
            progressBar.style.width = '0%';
            progressPercentage.textContent = '0%';
            currentEventDisplay.textContent = 'Starting approval process...';
            progressStatus.innerHTML = '';

            let successCount = 0;
            let failureCount = 0;
            const failures = [];

            // Process each schedule one at a time
            for (let i = 0; i < schedulesToApprove.length; i++) {
                const schedule = schedulesToApprove[i];
                const currentNum = i + 1;

                // Update progress display
                progressCount.textContent = `${currentNum} / ${totalCount}`;
                currentEventDisplay.textContent = `Scheduling: ${schedule.event_name} ‚Üí ${schedule.employee_name}`;

                try {
                    // Call the approve-single endpoint
                    const approveResponse = await fetch(`/auto-schedule/approve-single/${schedule.id}`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        }
                    });

                    const approveData = await approveResponse.json();

                    if (approveData.success) {
                        successCount++;
                    } else {
                        failureCount++;
                        failures.push({
                            event_name: schedule.event_name,
                            employee_name: schedule.employee_name,
                            error: approveData.error
                        });
                    }
                } catch (error) {
                    failureCount++;
                    failures.push({
                        event_name: schedule.event_name,
                        employee_name: schedule.employee_name,
                        error: error.message
                    });
                }

                // Update progress bar
                const percentage = Math.round((currentNum / totalCount) * 100);
                progressBar.style.width = `${percentage}%`;
                progressPercentage.textContent = `${percentage}%`;
            }

            // Mark the run as approved
            await fetch(`/auto-schedule/mark-approved/${runId}`, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json'
                }
            });

            // Show final status
            currentEventDisplay.textContent = 'All schedules processed!';

            let statusHtml = `<div class="progress-status ${failureCount > 0 ? 'warning' : 'success'}">`;
            statusHtml += `<strong>Approval Complete:</strong><br>`;
            statusHtml += `‚úì ${successCount} schedules submitted successfully<br>`;
            if (failureCount > 0) {
                statusHtml += `‚úó ${failureCount} schedules failed<br>`;
                statusHtml += `<div class="progress-details">`;
                failures.forEach(f => {
                    statusHtml += `<div class="progress-detail-item error">`;
                    statusHtml += `${f.event_name} ‚Üí ${f.employee_name}: ${f.error}`;
                    statusHtml += `</div>`;
                });
                statusHtml += `</div>`;
            }
            statusHtml += `<br><button onclick="window.location.href='{{ url_for("main.dashboard") }}'" class="btn-approve">Return to Dashboard</button>`;
            statusHtml += `</div>`;

            progressStatus.innerHTML = statusHtml;

        } catch (error) {
            showMessage('Failed to approve schedules: ' + error.message, 'error');
            this.disabled = false;
            this.textContent = originalText;
            progressModal.classList.remove('active');
        }
    });

    // Reject button handler
    document.getElementById('reject-button').addEventListener('click', async function () {
        if (!confirm('Reject ALL pending schedule proposals and return to dashboard? All proposed schedules will be permanently discarded.')) {
            return;
        }

        try {
            const response = await fetch('{{ url_for("auto_scheduler.reject_schedule") }}', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    reject_all: true
                })
            });

            const data = await response.json();

            if (response.ok && data.success) {
                showMessage(data.message, 'success');
                setTimeout(() => {
                    window.location.href = '{{ url_for("main.dashboard") }}';
                }, 1500);
            } else {
                showMessage('Error rejecting proposals: ' + (data.error || 'Unknown error'), 'error');
            }
        } catch (error) {
            showMessage('Failed to reject proposals: ' + error.message, 'error');
        }
    });

    // ============================================================
    // Edit Pending Schedule Modal Functions
    // ============================================================

    function openEditPendingModal(pendingId) {
        const data = pendingSchedulesData[pendingId];
        if (!data) {
            showMessage('Could not find schedule data', 'error');
            return;
        }

        // Populate hidden fields
        document.getElementById('edit-pending-id').value = pendingId;
        document.getElementById('edit-event-type').value = data.event_type;
        document.getElementById('edit-event-ref-num').value = data.event_ref_num;

        // Populate event info
        document.getElementById('edit-event-info').innerHTML = `
            <strong>${data.event_name}</strong><br>
            <small>Type: ${data.event_type} | Ref: ${data.event_ref_num}</small>
        `;

        // Set current date and time
        if (data.schedule_date) {
            document.getElementById('edit-date').value = data.schedule_date;
        }
        if (data.schedule_time) {
            document.getElementById('edit-time').value = data.schedule_time;
        }

        // Load available employees
        loadEmployeesForEdit(data.schedule_date, data.event_type, data.employee_id);

        // Show modal
        document.getElementById('edit-pending-modal').classList.add('active');
    }

    function closeEditPendingModal() {
        document.getElementById('edit-pending-modal').classList.remove('active');
        document.getElementById('edit-pending-form').reset();
    }

    async function loadEmployeesForEdit(date, eventType, currentEmployeeId) {
        const select = document.getElementById('edit-employee');
        select.innerHTML = '<option value="">Loading employees...</option>';

        try {
            // Use the role-filtered endpoint if date and event type are available
            let apiUrl = '/api/employees';
            if (date && eventType) {
                apiUrl = `/api/available_employees_for_change/${date}/${encodeURIComponent(eventType)}`;
                if (currentEmployeeId) {
                    apiUrl += `?current_employee_id=${currentEmployeeId}&current_date=${date}`;
                }
            }

            const response = await fetch(apiUrl);
            const employees = await response.json();

            select.innerHTML = '<option value="">Select an employee...</option>';

            // Handle both response formats (array directly or with filtering)
            const employeeList = Array.isArray(employees) ? employees : (employees.employees || []);

            employeeList
                .filter(emp => emp.is_active !== false)  // Filter active if property exists
                .forEach(emp => {
                    const option = document.createElement('option');
                    option.value = emp.id;
                    option.textContent = emp.job_title ? `${emp.name} (${emp.job_title})` : emp.name;
                    if (String(emp.id) === String(currentEmployeeId)) {
                        option.selected = true;
                    }
                    select.appendChild(option);
                });
        } catch (error) {
            console.error('Error loading employees:', error);
            select.innerHTML = '<option value="">Error loading employees</option>';
        }
    }

    // Edit form submission
    document.getElementById('edit-pending-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const pendingId = document.getElementById('edit-pending-id').value;
        const employeeId = document.getElementById('edit-employee').value;
        const date = document.getElementById('edit-date').value;
        const time = document.getElementById('edit-time').value;

        if (!employeeId || !date || !time) {
            showMessage('Please fill in all fields', 'error');
            return;
        }

        // Combine date and time into ISO datetime
        const scheduleDatetime = `${date}T${time}:00`;

        const saveBtn = this.querySelector('.btn-save');
        const originalText = saveBtn.textContent;
        saveBtn.disabled = true;
        saveBtn.textContent = 'Saving...';

        try {
            const response = await fetch(`/auto-schedule/api/pending/${pendingId}`, {
                method: 'PUT',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    employee_id: employeeId,
                    schedule_datetime: scheduleDatetime
                })
            });

            const result = await response.json();

            if (result.success) {
                showMessage('Schedule updated successfully', 'success');
                closeEditPendingModal();

                // Reload the page to reflect changes
                // (Could also update the table row inline for better UX)
                setTimeout(() => {
                    location.reload();
                }, 1000);
            } else {
                showMessage('Error: ' + (result.error || 'Failed to update schedule'), 'error');
            }
        } catch (error) {
            showMessage('Failed to update schedule: ' + error.message, 'error');
        } finally {
            saveBtn.disabled = false;
            saveBtn.textContent = originalText;
        }
    });

    // Click handler for edit buttons
    document.addEventListener('click', function (e) {
        if (e.target.classList.contains('btn-edit') && e.target.dataset.pendingId) {
            openEditPendingModal(e.target.dataset.pendingId);
        }
    });

    // Display verification results
    function displayVerificationResults(data) {
        const section = document.getElementById('verification-section');
        const icon = document.getElementById('verification-icon');
        const badge = document.getElementById('verification-badge');
        const content = document.getElementById('verification-content');
        const approveButton = document.getElementById('approve-button');

        section.style.display = 'block';

        const criticalCount = data.critical_issues ? data.critical_issues.length : 0;
        const warningCount = data.warnings ? data.warnings.length : 0;
        const infoCount = data.info ? data.info.length : 0;

        // Update badge and icon
        if (criticalCount > 0) {
            icon.textContent = '‚ùå';
            badge.textContent = `${criticalCount} Critical Issues`;
            badge.className = 'count-badge error';
            badge.style.background = '#e74c3c';

            // Disable approve button
            approveButton.disabled = true;
            approveButton.title = 'Cannot approve: Critical issues must be resolved';
        } else if (warningCount > 0) {
            icon.textContent = '‚ö†Ô∏è';
            badge.textContent = `${warningCount} Warnings`;
            badge.className = 'count-badge warning';
            badge.style.background = '#f39c12';
        } else {
            icon.textContent = '‚úÖ';
            badge.textContent = 'All Checks Passed';
            badge.className = 'count-badge success';
            badge.style.background = '#27ae60';
        }

        // Build content HTML
        let html = '';

        // Critical issues
        if (criticalCount > 0) {
            html += '<div class="alert alert-error" style="margin-bottom: 20px;">';
            html += '<strong>‚õî Critical Issues (Must Fix Before Approval):</strong>';
            html += '<ul style="margin: 10px 0 0 20px;">';
            data.critical_issues.forEach(issue => {
                html += `<li><strong>${issue.category}:</strong> ${issue.message}`;
                if (issue.action) {
                    html += `<br><em>Action: ${issue.action}</em>`;
                }
                html += '</li>';
            });
            html += '</ul></div>';
        }

        // Warnings
        if (warningCount > 0) {
            html += '<div class="alert alert-warning" style="margin-bottom: 20px;">';
            html += '<strong>‚ö†Ô∏è Warnings (Review Before Approval):</strong>';
            html += '<ul style="margin: 10px 0 0 20px;">';
            data.warnings.forEach(warning => {
                html += `<li><strong>${warning.category}:</strong> ${warning.message}`;
                if (warning.action) {
                    html += `<br><em>Suggestion: ${warning.action}</em>`;
                }
                html += '</li>';
            });
            html += '</ul></div>';
        }

        // Info messages
        if (infoCount > 0 && criticalCount === 0 && warningCount === 0) {
            html += '<div class="alert alert-success" style="margin-bottom: 20px;">';
            html += '<strong>‚ÑπÔ∏è Information:</strong>';
            html += '<ul style="margin: 10px 0 0 20px;">';
            data.info.forEach(info => {
                html += `<li>${info.message}</li>`;
            });
            html += '</ul></div>';
        }

        // If all passed
        if (criticalCount === 0 && warningCount === 0 && (!data.info || infoCount === 0)) {
            html += '<div class="alert alert-success">';
            html += '‚úÖ All verification checks passed! Schedule is ready for approval.';
            html += '</div>';
        }

        content.innerHTML = html;
    }

    // ============================================================
    // Manual Schedule Modal Functions (for failed events)
    // ============================================================

    function openManualScheduleModal(eventRefNum) {
        const event = failedEventsData[eventRefNum];
        if (!event) {
            showMessage('Could not find event data', 'error');
            return;
        }

        // Populate hidden fields
        document.getElementById('manual-event-ref-num').value = event.event_ref_num;
        document.getElementById('manual-event-type').value = event.event_type;

        // Populate event info
        document.getElementById('manual-event-info').innerHTML = `
            <strong>${event.event_name}</strong><br>
            <small>Type: ${event.event_type} | Ref: ${event.event_ref_num}</small><br>
            <small style="color: #e74c3c;">Failed: ${event.failure_reason || 'Unknown'}</small>
        `;

        // Set date constraints
        const dateInput = document.getElementById('manual-date');
        const dateHint = document.getElementById('manual-date-hint');

        if (event.start_date && event.end_date) {
            dateInput.min = event.start_date;
            dateInput.max = event.end_date;
            dateHint.textContent = `Valid dates: ${formatEventPeriod(event.start_date, event.end_date)}`;
        } else {
            dateInput.min = '';
            dateInput.max = '';
            dateHint.textContent = '';
        }

        // Reset form fields
        dateInput.value = event.start_date || '';
        document.getElementById('manual-time').innerHTML = '<option value="">Select a date first</option>';
        document.getElementById('manual-employee').innerHTML = '<option value="">Select a date and time first</option>';
        document.getElementById('manual-submit-btn').disabled = true;
        document.getElementById('manual-validation-message').style.display = 'none';

        // Load allowed times if date is set
        if (dateInput.value) {
            loadAllowedTimesForManual(event.event_type);
        }

        // Show modal
        document.getElementById('manual-schedule-modal').classList.add('active');
    }

    function closeManualScheduleModal() {
        document.getElementById('manual-schedule-modal').classList.remove('active');
    }

    async function loadAllowedTimesForManual(eventType) {
        const timeSelect = document.getElementById('manual-time');
        const dateInput = document.getElementById('manual-date');
        const selectedDate = dateInput ? dateInput.value : '';

        timeSelect.innerHTML = '<option value="">Loading times...</option>';

        try {
            let url = `/api/event-allowed-times/${encodeURIComponent(eventType)}`;
            if (selectedDate) {
                url += `?date=${encodeURIComponent(selectedDate)}`;
            }
            const response = await fetch(url);
            const data = await response.json();

            timeSelect.innerHTML = '<option value="">Select a time...</option>';

            if (data.allowed_times && data.allowed_times.length > 0) {
                // Use time_details if available (includes counts)
                if (data.time_details && data.time_details.length > 0) {
                    data.time_details.forEach(detail => {
                        const option = document.createElement('option');
                        option.value = detail.value;
                        option.textContent = detail.label; // e.g. "9:45 AM (2 scheduled)"
                        timeSelect.appendChild(option);
                    });
                } else {
                    // Fallback to allowed_times
                    data.allowed_times.forEach(time => {
                        const option = document.createElement('option');
                        option.value = time;
                        // Convert 24h to 12h for display
                        const [hours, minutes] = time.split(':');
                        const hour = parseInt(hours);
                        const ampm = hour >= 12 ? 'PM' : 'AM';
                        const displayHour = hour % 12 || 12;
                        option.textContent = `${displayHour}:${minutes} ${ampm}`;
                        timeSelect.appendChild(option);
                    });
                }
            } else {
                // Fallback: allow any time
                for (let h = 7; h <= 19; h++) {
                    ['00', '15', '30', '45'].forEach(m => {
                        const time = `${h.toString().padStart(2, '0')}:${m}`;
                        const option = document.createElement('option');
                        option.value = time;
                        const ampm = h >= 12 ? 'PM' : 'AM';
                        const displayHour = h % 12 || 12;
                        option.textContent = `${displayHour}:${m} ${ampm}`;
                        timeSelect.appendChild(option);
                    });
                }
            }
        } catch (error) {
            console.error('Error loading allowed times:', error);
            timeSelect.innerHTML = '<option value="">Error loading times</option>';
        }
    }

    async function loadEligibleEmployeesForManual() {
        const date = document.getElementById('manual-date').value;
        const time = document.getElementById('manual-time').value;
        const eventType = document.getElementById('manual-event-type').value;
        const employeeSelect = document.getElementById('manual-employee');
        const loadingDiv = document.getElementById('manual-employee-loading');

        if (!date || !time) {
            employeeSelect.innerHTML = '<option value="">Select a date and time first</option>';
            return;
        }

        employeeSelect.innerHTML = '<option value="">Loading employees...</option>';
        loadingDiv.style.display = 'block';

        try {
            // Use the role-filtered endpoint
            const response = await fetch(`/api/available_employees_for_change/${date}/${encodeURIComponent(eventType)}`);
            const data = await response.json();

            loadingDiv.style.display = 'none';
            employeeSelect.innerHTML = '<option value="">Select an employee...</option>';

            const employees = Array.isArray(data) ? data : (data.employees || []);

            if (employees.length === 0) {
                employeeSelect.innerHTML = '<option value="">No eligible employees available</option>';
            } else {
                employees
                    .filter(emp => emp.is_active !== false)
                    .forEach(emp => {
                        const option = document.createElement('option');
                        option.value = emp.id;
                        option.textContent = emp.job_title ? `${emp.name} (${emp.job_title})` : emp.name;
                        employeeSelect.appendChild(option);
                    });
            }
        } catch (error) {
            console.error('Error loading employees:', error);
            loadingDiv.style.display = 'none';
            employeeSelect.innerHTML = '<option value="">Error loading employees</option>';
        }

        updateManualSubmitButtonState();
    }

    function updateManualSubmitButtonState() {
        const date = document.getElementById('manual-date').value;
        const time = document.getElementById('manual-time').value;
        const employee = document.getElementById('manual-employee').value;
        const submitBtn = document.getElementById('manual-submit-btn');

        submitBtn.disabled = !(date && time && employee);
    }

    // Event listeners for manual schedule modal
    document.getElementById('manual-date').addEventListener('change', function () {
        const eventType = document.getElementById('manual-event-type').value;
        if (this.value && eventType) {
            loadAllowedTimesForManual(eventType);
        }
        // Reset employee when date changes
        document.getElementById('manual-employee').innerHTML = '<option value="">Select a time first</option>';
        updateManualSubmitButtonState();
    });

    document.getElementById('manual-time').addEventListener('change', function () {
        if (this.value) {
            loadEligibleEmployeesForManual();
        }
        updateManualSubmitButtonState();
    });

    document.getElementById('manual-employee').addEventListener('change', updateManualSubmitButtonState);

    // Form submission
    document.getElementById('manual-schedule-form').addEventListener('submit', async function (e) {
        e.preventDefault();

        const eventRefNum = document.getElementById('manual-event-ref-num').value;
        const employeeId = document.getElementById('manual-employee').value;
        const date = document.getElementById('manual-date').value;
        const time = document.getElementById('manual-time').value;
        const eventData = failedEventsData[eventRefNum];

        if (!employeeId || !date || !time) {
            showMessage('Please fill in all fields', 'error');
            return;
        }

        const submitBtn = document.getElementById('manual-submit-btn');
        const originalText = submitBtn.textContent;
        submitBtn.disabled = true;
        submitBtn.textContent = 'Scheduling...';

        try {
            // Combine date and time
            const scheduleDatetime = `${date}T${time}:00`;

            // Call the schedule-event API
            // Note: The API expects project_ref_num as event_id, not the internal database ID
            const response = await fetch('/api/schedule-event', {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    employee_id: employeeId,
                    event_id: eventRefNum,  // Use project_ref_num directly
                    schedule_datetime: scheduleDatetime
                })
            });

            const result = await response.json();

            if (result.success) {
                showMessage('Event scheduled successfully!', 'success');
                closeManualScheduleModal();

                // Clean up the pending schedule record
                try {
                    await fetch(`/auto-schedule/api/pending/by-ref/${eventRefNum}`, {
                        method: 'DELETE'
                    });
                } catch (cleanupError) {
                    console.warn('Could not clean up pending schedule:', cleanupError);
                }

                // Reload the page to reflect changes
                setTimeout(() => {
                    location.reload();
                }, 1000);
            } else {
                const validationMsg = document.getElementById('manual-validation-message');
                validationMsg.textContent = result.error || 'Failed to schedule event';
                validationMsg.style.display = 'block';
                validationMsg.className = 'validation-message error';
            }
        } catch (error) {
            showMessage('Failed to schedule event: ' + error.message, 'error');
        } finally {
            submitBtn.disabled = false;
            submitBtn.textContent = originalText;
        }
    });

    // Click handler for manual schedule buttons
    document.addEventListener('click', function (e) {
        if (e.target.classList.contains('btn-manual-schedule') && e.target.dataset.eventRef) {
            openManualScheduleModal(e.target.dataset.eventRef);
        }
    });

    {% endif %}
});
</script>
{% endblock %}